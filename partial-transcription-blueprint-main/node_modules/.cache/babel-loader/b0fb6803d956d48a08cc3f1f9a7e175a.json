{"ast":null,"code":"const util = require('util');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst mkdirp = require('mkdirp');\n\nconst errors = require('./errors');\n\nconst interpolation = require('./interpolation');\n/**\r\n * Regular Expression to match section headers.\r\n * @type {RegExp}\r\n * @private\r\n */\n\n\nconst SECTION = new RegExp(/\\s*\\[([^\\]]+)]/);\n/**\r\n * Regular expression to match key, value pairs.\r\n * @type {RegExp}\r\n * @private\r\n */\n\nconst KEY = new RegExp(/\\s*(.*?)\\s*[=:]\\s*(.*)/);\n/**\r\n * Regular expression to match comments. Either starting with a\r\n * semi-colon or a hash.\r\n * @type {RegExp}\r\n * @private\r\n */\n\nconst COMMENT = new RegExp(/^\\s*[;#]/); // RL1.6 Line Boundaries (for unicode)\n// ... it shall recognize not only CRLF, LF, CR,\n// but also NEL, PS and LS.\n\nconst LINE_BOUNDARY = new RegExp(/\\r\\n|[\\n\\r\\u0085\\u2028\\u2029]/g);\nconst readFileAsync = util.promisify(fs.readFile);\nconst writeFileAsync = util.promisify(fs.writeFile);\nconst statAsync = util.promisify(fs.stat);\nconst mkdirAsync = util.promisify(mkdirp);\n/**\r\n * @constructor\r\n */\n\nfunction ConfigParser() {\n  this._sections = {};\n}\n/**\r\n * Returns an array of the sections.\r\n * @returns {Array}\r\n */\n\n\nConfigParser.prototype.sections = function () {\n  return Object.keys(this._sections);\n};\n/**\r\n * Adds a section named section to the instance. If the section already\r\n * exists, a DuplicateSectionError is thrown.\r\n * @param {string} section - Section Name\r\n */\n\n\nConfigParser.prototype.addSection = function (section) {\n  if (this._sections.hasOwnProperty(section)) {\n    throw new errors.DuplicateSectionError(section);\n  }\n\n  this._sections[section] = {};\n};\n/**\r\n * Indicates whether the section is present in the configuration\r\n * file.\r\n * @param {string} section - Section Name\r\n * @returns {boolean}\r\n */\n\n\nConfigParser.prototype.hasSection = function (section) {\n  return this._sections.hasOwnProperty(section);\n};\n/**\r\n * Returns an array of all keys in the specified section.\r\n * @param {string} section - Section Name\r\n * @returns {Array}\r\n */\n\n\nConfigParser.prototype.keys = function (section) {\n  try {\n    return Object.keys(this._sections[section]);\n  } catch (err) {\n    throw new errors.NoSectionError(section);\n  }\n};\n/**\r\n * Indicates whether the specified key is in the section.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @returns {boolean}\r\n */\n\n\nConfigParser.prototype.hasKey = function (section, key) {\n  return this._sections.hasOwnProperty(section) && this._sections[section].hasOwnProperty(key);\n};\n/**\r\n * Reads a file and parses the configuration data.\r\n * @param {string|Buffer|int} file - Filename or File Descriptor\r\n */\n\n\nConfigParser.prototype.read = function (file) {\n  const lines = fs.readFileSync(file).toString('utf8').split(LINE_BOUNDARY);\n  parseLines.call(this, file, lines);\n};\n/**\r\n * Reads a file asynchronously and parses the configuration data.\r\n * @param {string|Buffer|int} file - Filename or File Descriptor\r\n */\n\n\nConfigParser.prototype.readAsync = async function (file) {\n  const lines = (await readFileAsync(file)).toString('utf8').split(LINE_BOUNDARY);\n  parseLines.call(this, file, lines);\n};\n/**\r\n * Gets the value for the key in the named section.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @param {boolean} [raw=false] - Whether or not to replace placeholders\r\n * @returns {string|undefined}\r\n */\n\n\nConfigParser.prototype.get = function (section, key, raw) {\n  if (this._sections.hasOwnProperty(section)) {\n    if (raw) {\n      return this._sections[section][key];\n    } else {\n      return interpolation.interpolate(this, section, key);\n    }\n  }\n\n  return undefined;\n};\n/**\r\n * Coerces value to an integer of the specified radix.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @param {int} [radix=10] - An integer between 2 and 36 that represents the base of the string.\r\n * @returns {number|undefined|NaN}\r\n */\n\n\nConfigParser.prototype.getInt = function (section, key, radix) {\n  if (this._sections.hasOwnProperty(section)) {\n    if (!radix) radix = 10;\n    return parseInt(this._sections[section][key], radix);\n  }\n\n  return undefined;\n};\n/**\r\n * Coerces value to a float.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @returns {number|undefined|NaN}\r\n */\n\n\nConfigParser.prototype.getFloat = function (section, key) {\n  if (this._sections.hasOwnProperty(section)) {\n    return parseFloat(this._sections[section][key]);\n  }\n\n  return undefined;\n};\n/**\r\n * Returns an object with every key, value pair for the named section.\r\n * @param {string} section - Section Name\r\n * @returns {Object}\r\n */\n\n\nConfigParser.prototype.items = function (section) {\n  return this._sections[section];\n};\n/**\r\n * Sets the given key to the specified value.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @param {*} value - New Key Value\r\n */\n\n\nConfigParser.prototype.set = function (section, key, value) {\n  if (this._sections.hasOwnProperty(section)) {\n    this._sections[section][key] = value;\n  }\n};\n/**\r\n * Removes the property specified by key in the named section.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @returns {boolean}\r\n */\n\n\nConfigParser.prototype.removeKey = function (section, key) {\n  // delete operator returns true if the property doesn't not exist\n  if (this._sections.hasOwnProperty(section) && this._sections[section].hasOwnProperty(key)) {\n    return delete this._sections[section][key];\n  }\n\n  return false;\n};\n/**\r\n * Removes the named section (and associated key, value pairs).\r\n * @param {string} section - Section Name\r\n * @returns {boolean}\r\n */\n\n\nConfigParser.prototype.removeSection = function (section) {\n  if (this._sections.hasOwnProperty(section)) {\n    return delete this._sections[section];\n  }\n\n  return false;\n};\n/**\r\n * Writes the representation of the config file to the\r\n * specified file. Comments are not preserved.\r\n * @param {string|Buffer|int} file - Filename or File Descriptor\r\n * @param {bool} [createMissingDirs=false] - Whether to create the directories in the path if they don't exist\r\n */\n\n\nConfigParser.prototype.write = function (file) {\n  let createMissingDirs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (createMissingDirs) {\n    const dir = path.dirname(file);\n    mkdirp.sync(dir);\n  }\n\n  fs.writeFileSync(file, getSectionsAsString.call(this));\n};\n/**\r\n * Writes the representation of the config file to the\r\n * specified file asynchronously. Comments are not preserved.\r\n * @param {string|Buffer|int} file - Filename or File Descriptor\r\n * @param {bool} [createMissingDirs=false] - Whether to create the directories in the path if they don't exist\r\n * @returns {Promise}\r\n */\n\n\nConfigParser.prototype.writeAsync = async function (file) {\n  let createMissingDirs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (createMissingDirs) {\n    const dir = path.dirname(file);\n    await mkdirAsync(dir);\n  }\n\n  await writeFileAsync(file, getSectionsAsString.call(this));\n};\n\nfunction parseLines(file, lines) {\n  let curSec = null;\n  lines.forEach((line, lineNumber) => {\n    if (!line || line.match(COMMENT)) return;\n    let res = SECTION.exec(line);\n\n    if (res) {\n      const header = res[1];\n      curSec = {};\n      this._sections[header] = curSec;\n    } else if (!curSec) {\n      throw new errors.MissingSectionHeaderError(file, lineNumber, line);\n    } else {\n      res = KEY.exec(line);\n\n      if (res) {\n        const key = res[1];\n        curSec[key] = res[2];\n      } else {\n        throw new errors.ParseError(file, lineNumber, line);\n      }\n    }\n  });\n}\n\nfunction getSectionsAsString() {\n  let out = '';\n  let section;\n\n  for (section in this._sections) {\n    if (!this._sections.hasOwnProperty(section)) continue;\n    out += '[' + section + ']\\n';\n    const keys = this._sections[section];\n    let key;\n\n    for (key in keys) {\n      if (!keys.hasOwnProperty(key)) continue;\n      let value = keys[key];\n      out += key + '=' + value + '\\n';\n    }\n\n    out += '\\n';\n  }\n\n  return out;\n}\n\nmodule.exports = ConfigParser;","map":{"version":3,"sources":["/Users/cando001/Documents/MyGit/blueprint/partial-transcription-blueprint-main/node_modules/configparser/src/configparser.js"],"names":["util","require","fs","path","mkdirp","errors","interpolation","SECTION","RegExp","KEY","COMMENT","LINE_BOUNDARY","readFileAsync","promisify","readFile","writeFileAsync","writeFile","statAsync","stat","mkdirAsync","ConfigParser","_sections","prototype","sections","Object","keys","addSection","section","hasOwnProperty","DuplicateSectionError","hasSection","err","NoSectionError","hasKey","key","read","file","lines","readFileSync","toString","split","parseLines","call","readAsync","get","raw","interpolate","undefined","getInt","radix","parseInt","getFloat","parseFloat","items","set","value","removeKey","removeSection","write","createMissingDirs","dir","dirname","sync","writeFileSync","getSectionsAsString","writeAsync","curSec","forEach","line","lineNumber","match","res","exec","header","MissingSectionHeaderError","ParseError","out","module","exports"],"mappings":"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","sourcesContent":["const util = require('util');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst mkdirp = require('mkdirp');\r\nconst errors = require('./errors');\r\nconst interpolation = require('./interpolation');\r\n\r\n/**\r\n * Regular Expression to match section headers.\r\n * @type {RegExp}\r\n * @private\r\n */\r\nconst SECTION = new RegExp(/\\s*\\[([^\\]]+)]/);\r\n\r\n/**\r\n * Regular expression to match key, value pairs.\r\n * @type {RegExp}\r\n * @private\r\n */\r\nconst KEY = new RegExp(/\\s*(.*?)\\s*[=:]\\s*(.*)/);\r\n\r\n/**\r\n * Regular expression to match comments. Either starting with a\r\n * semi-colon or a hash.\r\n * @type {RegExp}\r\n * @private\r\n */\r\nconst COMMENT = new RegExp(/^\\s*[;#]/);\r\n\r\n// RL1.6 Line Boundaries (for unicode)\r\n// ... it shall recognize not only CRLF, LF, CR,\r\n// but also NEL, PS and LS.\r\nconst LINE_BOUNDARY = new RegExp(/\\r\\n|[\\n\\r\\u0085\\u2028\\u2029]/g);\r\n\r\nconst readFileAsync = util.promisify(fs.readFile);\r\nconst writeFileAsync = util.promisify(fs.writeFile);\r\nconst statAsync = util.promisify(fs.stat);\r\nconst mkdirAsync = util.promisify(mkdirp);\r\n\r\n/**\r\n * @constructor\r\n */\r\nfunction ConfigParser() {\r\n    this._sections = {};\r\n}\r\n\r\n/**\r\n * Returns an array of the sections.\r\n * @returns {Array}\r\n */\r\nConfigParser.prototype.sections = function() {\r\n    return Object.keys(this._sections);\r\n};\r\n\r\n/**\r\n * Adds a section named section to the instance. If the section already\r\n * exists, a DuplicateSectionError is thrown.\r\n * @param {string} section - Section Name\r\n */\r\nConfigParser.prototype.addSection = function(section) {\r\n    if(this._sections.hasOwnProperty(section)){\r\n        throw new errors.DuplicateSectionError(section)\r\n    }\r\n    this._sections[section] = {};\r\n};\r\n\r\n/**\r\n * Indicates whether the section is present in the configuration\r\n * file.\r\n * @param {string} section - Section Name\r\n * @returns {boolean}\r\n */\r\nConfigParser.prototype.hasSection = function(section) {\r\n    return this._sections.hasOwnProperty(section);\r\n};\r\n\r\n/**\r\n * Returns an array of all keys in the specified section.\r\n * @param {string} section - Section Name\r\n * @returns {Array}\r\n */\r\nConfigParser.prototype.keys = function(section) {\r\n    try {\r\n        return Object.keys(this._sections[section]);\r\n    } catch(err){\r\n        throw new errors.NoSectionError(section);\r\n    }\r\n};\r\n\r\n/**\r\n * Indicates whether the specified key is in the section.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @returns {boolean}\r\n */\r\nConfigParser.prototype.hasKey = function (section, key) {\r\n    return this._sections.hasOwnProperty(section) &&\r\n        this._sections[section].hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Reads a file and parses the configuration data.\r\n * @param {string|Buffer|int} file - Filename or File Descriptor\r\n */\r\nConfigParser.prototype.read = function(file) {\r\n    const lines = fs.readFileSync(file)\r\n        .toString('utf8')\r\n        .split(LINE_BOUNDARY);\r\n    parseLines.call(this, file, lines);\r\n};\r\n\r\n/**\r\n * Reads a file asynchronously and parses the configuration data.\r\n * @param {string|Buffer|int} file - Filename or File Descriptor\r\n */\r\nConfigParser.prototype.readAsync = async function(file) {\r\n    const lines = (await readFileAsync(file))\r\n        .toString('utf8')\r\n        .split(LINE_BOUNDARY);\r\n    parseLines.call(this, file, lines);\r\n}\r\n\r\n/**\r\n * Gets the value for the key in the named section.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @param {boolean} [raw=false] - Whether or not to replace placeholders\r\n * @returns {string|undefined}\r\n */\r\nConfigParser.prototype.get = function(section, key, raw) {\r\n    if(this._sections.hasOwnProperty(section)){\r\n        if(raw){\r\n            return this._sections[section][key];\r\n        } else {\r\n            return interpolation.interpolate(this, section, key);\r\n        }\r\n    }\r\n    return undefined;\r\n};\r\n\r\n/**\r\n * Coerces value to an integer of the specified radix.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @param {int} [radix=10] - An integer between 2 and 36 that represents the base of the string.\r\n * @returns {number|undefined|NaN}\r\n */\r\nConfigParser.prototype.getInt = function(section, key, radix) {\r\n    if(this._sections.hasOwnProperty(section)){\r\n        if(!radix) radix = 10;\r\n        return parseInt(this._sections[section][key], radix);\r\n    }\r\n    return undefined;\r\n};\r\n\r\n/**\r\n * Coerces value to a float.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @returns {number|undefined|NaN}\r\n */\r\nConfigParser.prototype.getFloat = function(section, key) {\r\n    if(this._sections.hasOwnProperty(section)){\r\n        return parseFloat(this._sections[section][key]);\r\n    }\r\n    return undefined;\r\n};\r\n\r\n/**\r\n * Returns an object with every key, value pair for the named section.\r\n * @param {string} section - Section Name\r\n * @returns {Object}\r\n */\r\nConfigParser.prototype.items = function(section) {\r\n    return this._sections[section];\r\n};\r\n\r\n/**\r\n * Sets the given key to the specified value.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @param {*} value - New Key Value\r\n */\r\nConfigParser.prototype.set = function(section, key, value) {\r\n    if(this._sections.hasOwnProperty(section)){\r\n        this._sections[section][key] = value;\r\n    }\r\n};\r\n\r\n/**\r\n * Removes the property specified by key in the named section.\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n * @returns {boolean}\r\n */\r\nConfigParser.prototype.removeKey = function(section, key) {\r\n    // delete operator returns true if the property doesn't not exist\r\n    if(this._sections.hasOwnProperty(section) &&\r\n        this._sections[section].hasOwnProperty(key)){\r\n        return delete this._sections[section][key];\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Removes the named section (and associated key, value pairs).\r\n * @param {string} section - Section Name\r\n * @returns {boolean}\r\n */\r\nConfigParser.prototype.removeSection = function(section) {\r\n    if(this._sections.hasOwnProperty(section)){\r\n        return delete this._sections[section];\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Writes the representation of the config file to the\r\n * specified file. Comments are not preserved.\r\n * @param {string|Buffer|int} file - Filename or File Descriptor\r\n * @param {bool} [createMissingDirs=false] - Whether to create the directories in the path if they don't exist\r\n */\r\nConfigParser.prototype.write = function(file, createMissingDirs = false) {\r\n    if (createMissingDirs) {\r\n        const dir = path.dirname(file);\r\n        mkdirp.sync(dir);\r\n    }\r\n\r\n    fs.writeFileSync(file, getSectionsAsString.call(this));\r\n};\r\n\r\n/**\r\n * Writes the representation of the config file to the\r\n * specified file asynchronously. Comments are not preserved.\r\n * @param {string|Buffer|int} file - Filename or File Descriptor\r\n * @param {bool} [createMissingDirs=false] - Whether to create the directories in the path if they don't exist\r\n * @returns {Promise}\r\n */\r\nConfigParser.prototype.writeAsync = async function(file, createMissingDirs = false) {\r\n    if (createMissingDirs) {\r\n        const dir = path.dirname(file);\r\n        await mkdirAsync(dir);\r\n    }\r\n\r\n    await writeFileAsync(file, getSectionsAsString.call(this));\r\n}\r\n\r\nfunction parseLines(file, lines) {\r\n    let curSec = null;\r\n    lines.forEach((line, lineNumber) => {\r\n        if(!line || line.match(COMMENT)) return;\r\n        let res = SECTION.exec(line);\r\n        if(res){\r\n            const header = res[1];\r\n            curSec = {};\r\n            this._sections[header] = curSec;\r\n        } else if(!curSec) {\r\n            throw new errors.MissingSectionHeaderError(file, lineNumber, line);\r\n        } else {\r\n            res = KEY.exec(line);\r\n            if(res){\r\n                const key = res[1];\r\n                curSec[key] = res[2];\r\n            } else {\r\n                throw new errors.ParseError(file, lineNumber, line);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction getSectionsAsString() {\r\n    let out = '';\r\n    let section;\r\n    for(section in this._sections){\r\n        if(!this._sections.hasOwnProperty(section)) continue;\r\n        out += ('[' + section + ']\\n');\r\n        const keys = this._sections[section];\r\n        let key;\r\n        for(key in keys){\r\n            if(!keys.hasOwnProperty(key)) continue;\r\n            let value = keys[key];\r\n            out += (key + '=' + value + '\\n');\r\n        }\r\n        out += '\\n';\r\n    }\r\n    return out;\r\n}\r\n\r\nmodule.exports = ConfigParser;\r\n"]},"metadata":{},"sourceType":"script"}