{"ast":null,"code":"var _jsxFileName = \"/Users/cando001/Documents/MyGit/blueprint/partial-transcription-blueprint-main/src/components/queue-list/QueueList.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useState } from 'react';\nimport moment from 'moment';\nimport { addSubscription, removeSubscription, createChannel } from '../../utils/notificationsController';\nimport { Accordion } from '../accordion/Accordion';\nimport { Conversation } from '../conversation/Conversation';\nimport { authenticate, getQueues, getAgentByUserId, getActiveConversationsForQueue } from '../../utils/genesysCloudUtils';\nimport './QueueList.scss';\nimport { GenesysDevIcons, GenesysDevIcon } from 'genesys-dev-icons/lib/index';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar SpeakerTypes;\n\n(function (SpeakerTypes) {\n  SpeakerTypes[\"agent\"] = \"AGENT\";\n  SpeakerTypes[\"customer\"] = \"CUSTOMER\";\n})(SpeakerTypes || (SpeakerTypes = {}));\n\nexport let Standing;\n/**\n * High-level component for the Active Conversations Dashboard.\n * \n * @param props \n * @returns \n */\n\n(function (Standing) {\n  Standing[\"goodStanding\"] = \"Good Standing\";\n  Standing[\"badStanding\"] = \"Bad Standing\";\n})(Standing || (Standing = {}));\n\nexport function QueueList(props) {\n  _s();\n\n  let closedConversationIds = [];\n  let retryAfter = 0;\n  const badWords = ['um', 'uh', 'mm'];\n  const [queues, setQueues] = useState([]); // trigger initialization on component mount\n\n  useEffect(() => {\n    setupQueues(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  /*\n   * Initializes the data and subscriptions for the Active Conversations Dashboard\n   */\n\n  function setupQueues() {\n    let tempQueues; // authenticate logged-in user\n\n    authenticate().then(data => {\n      createChannel();\n      return data;\n    }) // retrieve all queues in the user's organization\n    .then(data => {\n      console.log('AUTH', data);\n      return getQueues();\n    }) // get the active conversations for the queues\n    .then(queueResponse => {\n      console.log('QUEUES', queueResponse);\n      tempQueues = queueResponse === null || queueResponse === void 0 ? void 0 : queueResponse.entities;\n      setQueues(tempQueues);\n      return Promise.all(tempQueues.map(queue => getActiveConversationsForQueue(queue.id)));\n    }) // get the assigned agent info for each active conversation\n    .then(async activeConversationResponse => {\n      console.log('ACTIVE CONVERSATION RESPONSE', activeConversationResponse);\n      return {\n        assignedAgentData: await Promise.all(tempQueues.map(async queue => {\n          const activeConversationsData = activeConversationResponse.find(data => (data === null || data === void 0 ? void 0 : data.queueId) && data.queueId === queue.id);\n          const activeConversations = (activeConversationsData === null || activeConversationsData === void 0 ? void 0 : activeConversationsData.conversations) || [];\n          return await Promise.all(activeConversations.map(async ac => {\n            var _ac$participants;\n\n            const agent = (_ac$participants = ac.participants) === null || _ac$participants === void 0 ? void 0 : _ac$participants.find(participant => {\n              var _participant$purpose;\n\n              return ((_participant$purpose = participant.purpose) === null || _participant$purpose === void 0 ? void 0 : _participant$purpose.toLowerCase()) === 'agent';\n            });\n            const agentId = (agent === null || agent === void 0 ? void 0 : agent.userId) || '';\n            const {\n              agentName,\n              imageUri\n            } = await getAgentByUserId(agentId);\n            return {\n              conversationId: ac.conversationId,\n              agentName,\n              imageUri\n            };\n          }));\n        })),\n        activeConversationResponse\n      };\n    }) // update the queues with active conversation data and subscribe to queue conversations\n    .then(combinedResponse => {\n      console.log('COMBINED RESPONSE', combinedResponse);\n      const {\n        activeConversationResponse,\n        assignedAgentData\n      } = combinedResponse;\n      tempQueues = tempQueues.map(queue => {\n        const activeConversationsData = activeConversationResponse === null || activeConversationResponse === void 0 ? void 0 : activeConversationResponse.find(data => (data === null || data === void 0 ? void 0 : data.queueId) && data.queueId === queue.id);\n        const activeConversations = (activeConversationsData === null || activeConversationsData === void 0 ? void 0 : activeConversationsData.conversations) || [];\n        return { ...queue,\n          conversationIds: activeConversations.map(ac => ac.conversationId),\n          conversations: activeConversations.map(ac => {\n            var _assignedAgentData$fl;\n\n            const agent = assignedAgentData === null || assignedAgentData === void 0 ? void 0 : (_assignedAgentData$fl = assignedAgentData.flat()) === null || _assignedAgentData$fl === void 0 ? void 0 : _assignedAgentData$fl.find(a => a.conversationId === ac.conversationId);\n            const agentName = (agent === null || agent === void 0 ? void 0 : agent.agentName) || '';\n            const imageUri = (agent === null || agent === void 0 ? void 0 : agent.imageUri) || '';\n            return {\n              assignedAgent: {\n                agentName,\n                imageUri\n              },\n              conversationId: ac.conversationId,\n              startTime: moment(ac.conversationStart)\n            };\n          })\n        };\n      });\n      setQueues(tempQueues);\n      tempQueues.map(queue => subscribeToQueueConversations(tempQueues, queue, queue.id));\n    }).catch(err => {\n      console.error(err);\n    });\n  }\n  /**\n   * Subscribes to conversation notifications of the organization's queues\n   * \n   * @param baseQueues the org's queues\n   * @param matchingQueue the queue to be updated in notification callback function\n   * @param queueId id of the matching queue\n   */\n\n\n  async function subscribeToQueueConversations(baseQueues, matchingQueue, queueId) {\n    var _matchingQueue$conver2;\n\n    const queueConversationTopic = `v2.routing.queues.${queueId}.conversations.calls`; // the callback fired when subscription notifications are received\n\n    const queueConversationCallback = async data => {\n      var _eventBody$participan, _eventBody$participan2, _eventBody$participan3, _matchingQueue$conver;\n\n      console.log('QUEUE CONVERSATION DATA', data);\n      const {\n        eventBody\n      } = data;\n      if (!matchingQueue || closedConversationIds.some(cid => cid === eventBody.id)) return;\n      const terminatedParticipantsLength = ((_eventBody$participan = eventBody.participants) === null || _eventBody$participan === void 0 ? void 0 : (_eventBody$participan2 = _eventBody$participan.filter(p => {\n        var _p$state, _p$state2;\n\n        return ((_p$state = p.state) === null || _p$state === void 0 ? void 0 : _p$state.toLowerCase()) === 'terminated' || ((_p$state2 = p.state) === null || _p$state2 === void 0 ? void 0 : _p$state2.toLowerCase()) === 'disconnected';\n      })) === null || _eventBody$participan2 === void 0 ? void 0 : _eventBody$participan2.length) || 0;\n      const participantsLength = ((_eventBody$participan3 = eventBody.participants) === null || _eventBody$participan3 === void 0 ? void 0 : _eventBody$participan3.length) || 0; // If the call is disconnected, remove the subscription\n\n      if (participantsLength && terminatedParticipantsLength === participantsLength) {\n        closedConversationIds.push(eventBody.id);\n        const newQueues = baseQueues.map(queue => {\n          var _queue$conversationId, _queue$conversations;\n\n          return { ...queue,\n            conversationIds: (_queue$conversationId = queue.conversationIds) === null || _queue$conversationId === void 0 ? void 0 : _queue$conversationId.filter(cId => cId !== eventBody.id),\n            conversations: (_queue$conversations = queue.conversations) === null || _queue$conversations === void 0 ? void 0 : _queue$conversations.filter(c => c.conversationId !== eventBody.id)\n          };\n        });\n        setQueues(newQueues);\n        return;\n      }\n\n      const conversationAlreadyPresent = ((_matchingQueue$conver = matchingQueue.conversationIds) === null || _matchingQueue$conver === void 0 ? void 0 : _matchingQueue$conver.length) > 0 && matchingQueue.conversationIds.some(cId => cId === data.eventBody.id); // update the matching queue with the new conversation, if not already present\n\n      if (!conversationAlreadyPresent) {\n        var _agent$user, _eventBody$participan4, _eventBody$participan5, _sortedParticipants$;\n\n        const agent = eventBody.participants.find(participant => participant.purpose.toLowerCase() === 'agent');\n        const agentId = (agent === null || agent === void 0 ? void 0 : (_agent$user = agent.user) === null || _agent$user === void 0 ? void 0 : _agent$user.id) || '';\n        const {\n          agentName,\n          imageUri\n        } = await getAgentByUserId(agentId);\n        const sortedParticipants = (_eventBody$participan4 = eventBody.participants) === null || _eventBody$participan4 === void 0 ? void 0 : (_eventBody$participan5 = _eventBody$participan4.filter(p => p.connectedTime)) === null || _eventBody$participan5 === void 0 ? void 0 : _eventBody$participan5.sort((p1, p2) => {\n          const moment1 = moment(p1.connectedTime);\n          const moment2 = moment(p2.connectedTime);\n          if (moment1.isBefore(moment2)) return -1;else if (moment1.isAfter(moment2)) return 1;else return 0;\n        });\n        const startString = (sortedParticipants === null || sortedParticipants === void 0 ? void 0 : (_sortedParticipants$ = sortedParticipants[0]) === null || _sortedParticipants$ === void 0 ? void 0 : _sortedParticipants$.connectedTime) || '';\n        const newQueue = { ...matchingQueue,\n          conversationIds: [...(matchingQueue.conversationIds || []), eventBody.id],\n          conversations: [...(matchingQueue.conversations || []), {\n            assignedAgent: {\n              agentName,\n              imageUri\n            },\n            conversationId: eventBody.id,\n            startTime: moment(startString || 0)\n          }]\n        };\n        const newQueues = [...baseQueues];\n        const queueIndex = queues.indexOf(matchingQueue);\n        newQueues.splice(queueIndex, 1, newQueue);\n        setQueues(newQueues); // subscribe to transcripts of the new conversation\n\n        subscribeToTranscript(newQueues, data.eventBody.id);\n      }\n    }; // subscribe to transcripts of initial conversations\n\n\n    (_matchingQueue$conver2 = matchingQueue.conversationIds) === null || _matchingQueue$conver2 === void 0 ? void 0 : _matchingQueue$conver2.forEach(cId => subscribeToTranscript(baseQueues, cId)); // subscribe to the queue's conversations\n\n    addSubscriptionWrapper(queueConversationTopic, queueConversationCallback);\n  }\n\n  async function addSubscriptionWrapper(topic, cb) {\n    if (retryAfter > 0) {\n      const timeout = retryAfter * 1000;\n      setTimeout(() => {\n        retryAfter = 0;\n        addSubscriptionWrapper(topic, cb);\n      }, timeout);\n    } else {\n      const err = await addSubscription(topic, cb);\n\n      if (err && err.status === 429) {\n        retryAfter = err.headers['retry-after'];\n        const timeout = retryAfter * 1000;\n        setTimeout(() => {\n          retryAfter = 0;\n          addSubscriptionWrapper(topic, cb);\n        }, timeout);\n      }\n    }\n  }\n  /**\n   * Subscribe to the transcripts of an active conversation\n   * \n   * @param baseQueues the org's queues \n   * @param conversationId the id of the conversation\n   * @returns \n   */\n\n\n  async function subscribeToTranscript(baseQueues, conversationId) {\n    if (!conversationId) return;\n    const transcriptionTopic = `v2.conversations.${conversationId}.transcription`; // the callback triggered when a transcription notification is received\n\n    const transcriptionCallback = data => {\n      var _matchingQueue$conver3, _eventBody$status, _eventBody$transcript, _matchingQueue$conver4;\n\n      console.log('CONVERSATION NOTIFICATION', data); // unpack relevant data from response\n\n      const {\n        eventBody\n      } = data;\n      const {\n        eventTime,\n        transcripts\n      } = eventBody; // find the matching queue and conversation\n\n      const matchingQueue = baseQueues.find(queue => {\n        var _queue$conversationId2;\n\n        return (_queue$conversationId2 = queue.conversationIds) === null || _queue$conversationId2 === void 0 ? void 0 : _queue$conversationId2.some(id => id === conversationId);\n      });\n      const matchingConversation = matchingQueue === null || matchingQueue === void 0 ? void 0 : (_matchingQueue$conver3 = matchingQueue.conversationIds) === null || _matchingQueue$conver3 === void 0 ? void 0 : _matchingQueue$conver3.find(cId => cId === conversationId);\n      if (!matchingQueue || !matchingConversation || closedConversationIds.some(cId => cId === conversationId)) return; // If the call is disconnected, remove the subscription\n\n      if (((_eventBody$status = eventBody.status) === null || _eventBody$status === void 0 ? void 0 : _eventBody$status.status) === 'SESSION_ENDED') {\n        cancelSubscription(transcriptionTopic);\n        closedConversationIds.push(conversationId);\n        const newQueues = baseQueues.map(queue => {\n          var _queue$conversationId3, _queue$conversations2;\n\n          return { ...queue,\n            conversationIds: (_queue$conversationId3 = queue.conversationIds) === null || _queue$conversationId3 === void 0 ? void 0 : _queue$conversationId3.filter(cId => cId !== eventBody.conversationId),\n            conversations: (_queue$conversations2 = queue.conversations) === null || _queue$conversations2 === void 0 ? void 0 : _queue$conversations2.filter(c => c.conversationId !== eventBody.conversationId)\n          };\n        });\n        setQueues(newQueues);\n        return;\n      } // determine whether the agent spoke a word that puts the conversation in bad standing\n\n\n      const agentSpokeBadWord = (_eventBody$transcript = eventBody.transcripts) === null || _eventBody$transcript === void 0 ? void 0 : _eventBody$transcript.some(transcript => {\n        return transcript.channel.toLowerCase() === 'internal' && badWords.some(badWord => {\n          var _transcript$alternati, _transcript$alternati2, _transcript$alternati3, _transcript$alternati4;\n\n          return (_transcript$alternati = transcript.alternatives) === null || _transcript$alternati === void 0 ? void 0 : (_transcript$alternati2 = _transcript$alternati[0]) === null || _transcript$alternati2 === void 0 ? void 0 : (_transcript$alternati3 = _transcript$alternati2.transcript) === null || _transcript$alternati3 === void 0 ? void 0 : (_transcript$alternati4 = _transcript$alternati3.toLowerCase()) === null || _transcript$alternati4 === void 0 ? void 0 : _transcript$alternati4.includes(badWord);\n        });\n      }); // add the new interactions\n\n      const newInteractions = (transcripts || []).map(transcript => {\n        var _transcript$alternati5;\n\n        const origin = transcript.channel.toLowerCase();\n        const speaker = origin === 'internal' ? SpeakerTypes.agent : SpeakerTypes.customer;\n        return {\n          speaker,\n          timestamp: eventTime,\n          transcript: ((_transcript$alternati5 = transcript.alternatives) === null || _transcript$alternati5 === void 0 ? void 0 : _transcript$alternati5[0].transcript) || ''\n        };\n      });\n      const newConversations = (_matchingQueue$conver4 = matchingQueue.conversations) === null || _matchingQueue$conver4 === void 0 ? void 0 : _matchingQueue$conver4.map(conversation => {\n        if (conversation.conversationId === conversationId) {\n          var _eventBody$status2;\n\n          return { ...conversation,\n            startTime: conversation.startTime || moment(eventBody.sessionStartTimeMs || 0),\n            status: (_eventBody$status2 = eventBody.status) === null || _eventBody$status2 === void 0 ? void 0 : _eventBody$status2.status,\n            interactions: [...newInteractions, ...(conversation.interactions || [])],\n            standing: agentSpokeBadWord ? Standing.badStanding : conversation.standing\n          };\n        } else {\n          return conversation;\n        }\n      }); // update the queue with the new interactions\n\n      const newQueue = { ...matchingQueue,\n        conversations: newConversations\n      };\n      const newQueues = [...baseQueues];\n      const queueIndex = queues.indexOf(matchingQueue);\n      newQueues.splice(queueIndex, 1, newQueue);\n      setQueues(newQueues);\n    };\n\n    addSubscriptionWrapper(transcriptionTopic, transcriptionCallback);\n  }\n  /**\n   * Removes the subscription when a conversation ends.\n   * \n   * @param topic the subscription topic for removal\n   */\n\n\n  async function cancelSubscription(topic) {\n    await removeSubscription(topic, () => console.log(`Removed subscription to topic: ${topic}`));\n  }\n  /*\n   * Renders the accordion components of the Active Conversation Dashboard\n   */\n\n\n  function renderQueueCards() {\n    const queueSections = queues.map(queue => {\n      var _queue$conversationId4, _queue$conversationId5;\n\n      queue.conversations && console.log('QUEUE CONVERSATIONS', queue.conversations); // setup conversations\n\n      const conversationSections = (queue.conversations || []).map(conversation => {\n        var _conversation$assigne, _conversation$startTi;\n\n        const section = {\n          sectionClass: conversation.standing === Standing.badStanding ? 'accordion-section--bad-standing' : 'accordion-section--good-standing',\n          contentClass: 'content--conversation',\n          heading: /*#__PURE__*/_jsxDEV(React.Fragment, {\n            children: [/*#__PURE__*/_jsxDEV(\"span\", {\n              className: conversation.standing === Standing.badStanding ? 'standing-header--bad' : 'standing-header--good',\n              children: conversation.standing === Standing.badStanding ? /*#__PURE__*/_jsxDEV(GenesysDevIcon, {\n                icon: GenesysDevIcons.AppWarnSolid\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 456,\n                columnNumber: 21\n              }, this) : /*#__PURE__*/_jsxDEV(GenesysDevIcon, {\n                icon: GenesysDevIcons.AppCheckSolid\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 457,\n                columnNumber: 21\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 454,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"agent-name-title\",\n              children: (_conversation$assigne = conversation.assignedAgent) === null || _conversation$assigne === void 0 ? void 0 : _conversation$assigne.agentName\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 460,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n              className: \"start-title\",\n              children: [\"Active since \", `${(_conversation$startTi = conversation.startTime) === null || _conversation$startTi === void 0 ? void 0 : _conversation$startTi.format('h:mm a').toString()}`]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 461,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 453,\n            columnNumber: 13\n          }, this),\n          content: /*#__PURE__*/_jsxDEV(Conversation, {\n            conversation: conversation\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 467,\n            columnNumber: 13\n          }, this),\n          showExpanded: false\n        };\n        return section;\n      });\n      const conversationHeaderClass = ((_queue$conversationId4 = queue.conversationIds) === null || _queue$conversationId4 === void 0 ? void 0 : _queue$conversationId4.length) > 0 ? 'active-header' : 'inactive-header';\n      const section = {\n        heading: /*#__PURE__*/_jsxDEV(React.Fragment, {\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"queue__header-left\",\n            children: queue.name || ''\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 479,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n            className: conversationHeaderClass,\n            children: `${((_queue$conversationId5 = queue.conversationIds) === null || _queue$conversationId5 === void 0 ? void 0 : _queue$conversationId5.length) || 0} active conversations`\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 480,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 478,\n          columnNumber: 11\n        }, this),\n        content: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"conversations-container\",\n          children: /*#__PURE__*/_jsxDEV(Accordion, {\n            sections: conversationSections,\n            innerClass: \"inner-accordion\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 485,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 484,\n          columnNumber: 11\n        }, this),\n        showExpanded: false\n      };\n      return section;\n    });\n    return /*#__PURE__*/_jsxDEV(Accordion, {\n      sections: queueSections,\n      outerClass: \"outer-accordion\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 494,\n      columnNumber: 7\n    }, this);\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"queue\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"queue-title\",\n      children: [/*#__PURE__*/_jsxDEV(\"span\", {\n        children: /*#__PURE__*/_jsxDEV(\"span\", {\n          children: \"Active Conversation Dashboard\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 501,\n          columnNumber: 17\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 501,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"This is a list of the queues in your organization.  Expand one to see the active conversations for the queue.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 502,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 500,\n      columnNumber: 7\n    }, this), renderQueueCards()]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 499,\n    columnNumber: 5\n  }, this);\n}\n\n_s(QueueList, \"h8umRsSdMZEM7JulrbGc4xbRjTI=\");\n\n_c = QueueList;\n\nvar _c;\n\n$RefreshReg$(_c, \"QueueList\");","map":{"version":3,"sources":["/Users/cando001/Documents/MyGit/blueprint/partial-transcription-blueprint-main/src/components/queue-list/QueueList.tsx"],"names":["React","useEffect","useState","moment","addSubscription","removeSubscription","createChannel","Accordion","Conversation","authenticate","getQueues","getAgentByUserId","getActiveConversationsForQueue","GenesysDevIcons","GenesysDevIcon","SpeakerTypes","Standing","QueueList","props","closedConversationIds","retryAfter","badWords","queues","setQueues","setupQueues","tempQueues","then","data","console","log","queueResponse","entities","Promise","all","map","queue","id","activeConversationResponse","assignedAgentData","activeConversationsData","find","queueId","activeConversations","conversations","ac","agent","participants","participant","purpose","toLowerCase","agentId","userId","agentName","imageUri","conversationId","combinedResponse","conversationIds","flat","a","assignedAgent","startTime","conversationStart","subscribeToQueueConversations","catch","err","error","baseQueues","matchingQueue","queueConversationTopic","queueConversationCallback","eventBody","some","cid","terminatedParticipantsLength","filter","p","state","length","participantsLength","push","newQueues","cId","c","conversationAlreadyPresent","user","sortedParticipants","connectedTime","sort","p1","p2","moment1","moment2","isBefore","isAfter","startString","newQueue","queueIndex","indexOf","splice","subscribeToTranscript","forEach","addSubscriptionWrapper","topic","cb","timeout","setTimeout","status","headers","transcriptionTopic","transcriptionCallback","eventTime","transcripts","matchingConversation","cancelSubscription","agentSpokeBadWord","transcript","channel","badWord","alternatives","includes","newInteractions","origin","speaker","customer","timestamp","newConversations","conversation","sessionStartTimeMs","interactions","standing","badStanding","renderQueueCards","queueSections","conversationSections","section","sectionClass","contentClass","heading","AppWarnSolid","AppCheckSolid","format","toString","content","showExpanded","conversationHeaderClass","name"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport moment from 'moment';\nimport { \n  addSubscription,\n  removeSubscription,\n  createChannel\n} from '../../utils/notificationsController';\nimport { Accordion, AccordionData } from '../accordion/Accordion';\nimport { Conversation } from '../conversation/Conversation';\nimport { \n  authenticate,\n  getQueues,\n  getAgentByUserId,\n  getActiveConversationsForQueue,\n} from '../../utils/genesysCloudUtils';\nimport './QueueList.scss';\nimport { GenesysDevIcons, GenesysDevIcon } from 'genesys-dev-icons/lib/index';\n\ninterface Agent {\n  agentName: string,\n  imageUri?: string\n}\n\ninterface ActiveConversationData {\n  queueId: string,\n  conversations: ActiveConversation[]\n}\n\ninterface ActiveConversation {\n  conversationId: string,\n  participants: Participant[]\n}\n\nexport interface IConversation {\n  assignedAgent?: Agent,\n  conversationId: string,\n  interactions?: Interaction[],\n  startTime?: moment.Moment,\n  status?: string,\n  standing?: Standing\n}\n\nexport interface Interaction {\n  speaker: SpeakerTypes,\n  timestamp: string,\n  transcript: string\n}\n\ninterface Queue {\n  conversationIds: string[],\n  conversations: IConversation[]\n  activeUsers: number,\n  id: string,\n  isExpanded: boolean,\n  name: string,\n  onQueueUsers: number\n}\n\ninterface QueueResponse {\n  entities: Queue[]\n}\n\ninterface Word {\n  confidence: number,\n  offsetMs: number,\n  durationMs: number,\n  word: string\n}\n\ninterface Alternative {\n  offsetMs: number,\n  durationMs: number,\n  transcript: string,\n  words: Word[]\n}\n\ninterface Status {\n  offsetMs: number,\n  status: string\n}\n\ninterface Transcript {\n  utteranceId: string,\n  isFinal: boolean,\n  channel: string,\n  alternatives: Alternative[],\n  engineId: string,\n  dialect: string,\n  agentAssistEnabled: false,\n  voiceTranscriptionEnabled: true\n}\n\ninterface TranscriptEventBody {\n  eventTime: string,\n  organizationId: string,\n  conversationId: string,\n  communicationId: string,\n  sessionStartTimeMs: number,\n  transcriptionStartTimeMs: number,\n  transcripts: Transcript[],\n  status: Status\n}\n\ninterface Metadata {\n  CorrelationId: string\n}\n\ninterface TranscriptEvent {\n  topicName: string,\n  version: string,\n  eventBody: TranscriptEventBody,\n  metadata: Metadata\n}\n\ninterface QueueConversationEvent { \n  eventBody: {\n    id: string,\n    conversationStart: string,\n    recordingState: string,\n    participants: Participant[]\n  }\n}\n\ninterface Participant {\n  connectedTime?: string,\n  endTime?: string,\n  state: string,\n  purpose: string,\n  user?: {\n    id: string\n  }\n}\n\nenum SpeakerTypes {\n  agent = 'AGENT',\n  customer = 'CUSTOMER'\n}\n\nexport enum Standing {\n  goodStanding = 'Good Standing',\n  badStanding = 'Bad Standing'\n}\n\n/**\n * High-level component for the Active Conversations Dashboard.\n * \n * @param props \n * @returns \n */\nexport function QueueList(props: any) {\n\n  let closedConversationIds: string[] = [];\n  let retryAfter: number = 0;\n  const badWords: string[] = ['um', 'uh', 'mm'];\n\n  const [queues, setQueues] = useState<Queue[]>([]);\n\n  // trigger initialization on component mount\n  useEffect(() => {\n    setupQueues(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  \n  /*\n   * Initializes the data and subscriptions for the Active Conversations Dashboard\n   */\n  function setupQueues() {\n    let tempQueues: Queue[];\n    // authenticate logged-in user\n    authenticate()\n      .then((data: any) => {\n        createChannel();\n        return data;\n      })\n      // retrieve all queues in the user's organization\n      .then((data: any) => {\n        console.log('AUTH', data);\n        return getQueues();\n      })\n      // get the active conversations for the queues\n      .then((queueResponse: QueueResponse) => {\n        console.log('QUEUES', queueResponse);\n        tempQueues = queueResponse?.entities;\n        setQueues(tempQueues);\n\n        return Promise.all(tempQueues.map((queue: Queue) => getActiveConversationsForQueue(queue.id)))\n      })\n      // get the assigned agent info for each active conversation\n      .then(async (activeConversationResponse: ActiveConversationData[]) => {\n        console.log('ACTIVE CONVERSATION RESPONSE', activeConversationResponse);\n\n        return {\n          assignedAgentData: await Promise.all(tempQueues.map(async (queue: Queue) => {\n            const activeConversationsData = activeConversationResponse.find((data: any) => data?.queueId && data.queueId === queue.id);\n            const activeConversations = activeConversationsData?.conversations || [];\n\n            return await Promise.all(activeConversations.map(async (ac: any) => {\n              const agent: any = ac.participants?.find((participant: Participant) => participant.purpose?.toLowerCase() === 'agent');\n              const agentId: string = agent?.userId || '';\n              const { agentName, imageUri } = await getAgentByUserId(agentId);\n\n              return { conversationId: ac.conversationId, agentName, imageUri };\n            }));\n          })),\n          activeConversationResponse\n        }\n      })\n      // update the queues with active conversation data and subscribe to queue conversations\n      .then((combinedResponse: any) => {\n        console.log('COMBINED RESPONSE', combinedResponse);\n        const { activeConversationResponse, assignedAgentData } = combinedResponse;\n        tempQueues = tempQueues.map((queue: Queue) => {\n          const activeConversationsData = activeConversationResponse?.find((data: any) => data?.queueId && data.queueId === queue.id);\n          const activeConversations = activeConversationsData?.conversations || [];\n\n          return {\n            ...queue,\n            conversationIds: activeConversations.map((ac: any) => ac.conversationId),\n            conversations: activeConversations.map((ac: any) => {\n              const agent: any =  assignedAgentData?.flat()?.find((a: any) => a.conversationId === ac.conversationId)\n              const agentName: string = agent?.agentName || '';\n              const imageUri: string = agent?.imageUri || '';\n\n              return {\n                assignedAgent: { agentName, imageUri },\n                conversationId: ac.conversationId,\n                startTime: moment(ac.conversationStart)\n              };\n            })\n          };\n        })\n        setQueues(tempQueues);\n        tempQueues.map((queue: Queue) => subscribeToQueueConversations(tempQueues, queue, queue.id));\n      })\n      .catch((err: any) => {\n        console.error(err);\n      });\n  }\n\n  /**\n   * Subscribes to conversation notifications of the organization's queues\n   * \n   * @param baseQueues the org's queues\n   * @param matchingQueue the queue to be updated in notification callback function\n   * @param queueId id of the matching queue\n   */\n  async function subscribeToQueueConversations(baseQueues: Queue[], matchingQueue: Queue, queueId: string) {\n    const queueConversationTopic: string = `v2.routing.queues.${queueId}.conversations.calls`;\n\n    // the callback fired when subscription notifications are received\n    const queueConversationCallback = async (data: QueueConversationEvent) => {\n      console.log('QUEUE CONVERSATION DATA', data);\n      const { eventBody } = data;\n\n      if (!matchingQueue || closedConversationIds.some((cid: string) => cid === eventBody.id)) return;\n      \n      const terminatedParticipantsLength = eventBody.participants?.filter((p: Participant) => p.state?.toLowerCase() === 'terminated' || p.state?.toLowerCase() === 'disconnected')?.length || 0;\n      const participantsLength = eventBody.participants?.length || 0;\n    \n      // If the call is disconnected, remove the subscription\n      if (participantsLength && terminatedParticipantsLength === participantsLength) {\n        closedConversationIds.push(eventBody.id);\n        const newQueues: Queue[] = baseQueues.map((queue: Queue) => {\n          return {\n            ...queue,\n            conversationIds: queue.conversationIds?.filter((cId: string) => cId !== eventBody.id),\n            conversations: queue.conversations?.filter((c: IConversation) => c.conversationId !== eventBody.id)\n          }\n        });\n        setQueues(newQueues);\n        return;\n      }\n\n      const conversationAlreadyPresent = matchingQueue.conversationIds?.length > 0 \n        && matchingQueue.conversationIds.some((cId: string) => cId === data.eventBody.id);\n      \n      // update the matching queue with the new conversation, if not already present\n      if (!conversationAlreadyPresent) {\n        const agent: Participant | undefined = eventBody.participants.find((participant: Participant) => participant.purpose.toLowerCase() === 'agent');\n        const agentId: string = agent?.user?.id || '';\n        const { agentName, imageUri } = await getAgentByUserId(agentId);\n\n        const sortedParticipants: Participant[] = eventBody.participants\n          ?.filter((p: Participant) => p.connectedTime)\n          ?.sort((p1: Participant, p2: Participant) => {\n            const moment1: moment.Moment = moment(p1.connectedTime);\n            const moment2: moment.Moment = moment(p2.connectedTime);\n            if (moment1.isBefore(moment2)) return -1;\n            else if (moment1.isAfter(moment2)) return 1;\n            else return 0;\n          });\n        \n        const startString: string = sortedParticipants?.[0]?.connectedTime || '';\n        const newQueue: Queue = {\n          ...matchingQueue,\n          conversationIds: [...(matchingQueue.conversationIds || []), eventBody.id],\n          conversations: [...(matchingQueue.conversations || []), {\n            assignedAgent: { agentName, imageUri },\n            conversationId: eventBody.id,\n            startTime: moment(startString || 0)\n          }]\n        };\n      \n        const newQueues: Queue[] = [...baseQueues];\n        const queueIndex = queues.indexOf(matchingQueue);\n        newQueues.splice(queueIndex, 1, newQueue);\n      \n        setQueues(newQueues);\n\n        // subscribe to transcripts of the new conversation\n        subscribeToTranscript(newQueues, data.eventBody.id);\n      }\n    }\n    // subscribe to transcripts of initial conversations\n    matchingQueue.conversationIds?.forEach((cId: string) => subscribeToTranscript(baseQueues, cId));\n    // subscribe to the queue's conversations\n    addSubscriptionWrapper(queueConversationTopic, queueConversationCallback);\n  }\n\n  async function addSubscriptionWrapper(topic: string, cb: any) {\n    if (retryAfter > 0) {\n      const timeout = retryAfter * 1000;\n      setTimeout(() => {\n        retryAfter = 0;\n        addSubscriptionWrapper(topic, cb);\n      }, timeout);\n    } else {\n      const err = await addSubscription(topic, cb);\n      if (err && err.status === 429) {\n        retryAfter = err.headers['retry-after'];\n        const timeout = retryAfter * 1000;\n        setTimeout(() => {\n          retryAfter = 0;\n          addSubscriptionWrapper(topic, cb);\n        }, timeout);\n      }\n    }\n  }\n\n  /**\n   * Subscribe to the transcripts of an active conversation\n   * \n   * @param baseQueues the org's queues \n   * @param conversationId the id of the conversation\n   * @returns \n   */\n  async function subscribeToTranscript(baseQueues: Queue[], conversationId: string) {\n    if (!conversationId) return;\n\n    const transcriptionTopic = `v2.conversations.${conversationId}.transcription`;\n\n    // the callback triggered when a transcription notification is received\n    const transcriptionCallback = (data: TranscriptEvent) => {\n      console.log('CONVERSATION NOTIFICATION', data);\n\n      // unpack relevant data from response\n      const { eventBody } = data;\n      const { eventTime, transcripts } = eventBody;\n      \n      // find the matching queue and conversation\n      const matchingQueue = baseQueues.find((queue: Queue) => queue.conversationIds?.some((id: string) => id === conversationId));\n      const matchingConversation = matchingQueue?.conversationIds?.find((cId: string) => cId === conversationId);\n\n      if (!matchingQueue || !matchingConversation || closedConversationIds.some((cId: string) => cId === conversationId)) return;\n\n      // If the call is disconnected, remove the subscription\n      if (eventBody.status?.status === 'SESSION_ENDED') {\n        cancelSubscription(transcriptionTopic);\n        closedConversationIds.push(conversationId);\n        const newQueues: Queue[] = baseQueues.map((queue: Queue) => {\n          return {\n            ...queue,\n            conversationIds: queue.conversationIds?.filter((cId: string) => cId !== eventBody.conversationId),\n            conversations: queue.conversations?.filter((c: IConversation) => c.conversationId !== eventBody.conversationId)\n          }\n        });\n        setQueues(newQueues);\n        return;\n      }\n\n      // determine whether the agent spoke a word that puts the conversation in bad standing\n      const agentSpokeBadWord: boolean = eventBody.transcripts?.some((transcript: Transcript) => {\n        return transcript.channel.toLowerCase() === 'internal' \n          && badWords.some((badWord: string) => transcript.alternatives?.[0]?.transcript?.toLowerCase()?.includes(badWord));\n      });\n\n      // add the new interactions\n      const newInteractions: Interaction[] = (transcripts || []).map((transcript: Transcript) => {\n        const origin = transcript.channel.toLowerCase();\n        const speaker: SpeakerTypes = origin === 'internal' ? SpeakerTypes.agent : SpeakerTypes.customer;\n        return {\n          speaker,\n          timestamp: eventTime,\n          transcript: transcript.alternatives?.[0].transcript || ''\n        };\n      })\n\n      const newConversations: IConversation[] = matchingQueue.conversations?.map((conversation: IConversation) => {\n          if (conversation.conversationId === conversationId) {\n            return {\n              ...conversation,\n              startTime: conversation.startTime || moment(eventBody.sessionStartTimeMs || 0),\n              status: eventBody.status?.status,\n              interactions: [\n                ...newInteractions,\n                ...(conversation.interactions || [])\n              ],\n              standing: agentSpokeBadWord ? Standing.badStanding : conversation.standing\n            }\n          } else {\n            return conversation;\n          }\n      });\n\n      // update the queue with the new interactions\n      const newQueue: Queue = {\n        ...matchingQueue,\n        conversations: newConversations\n      };\n\n      const newQueues: Queue[] = [...baseQueues];\n      const queueIndex = queues.indexOf(matchingQueue);\n      newQueues.splice(queueIndex, 1, newQueue);\n\n      setQueues(newQueues);\n    };\n    addSubscriptionWrapper(transcriptionTopic, transcriptionCallback);\n  }\n\n  /**\n   * Removes the subscription when a conversation ends.\n   * \n   * @param topic the subscription topic for removal\n   */\n  async function cancelSubscription(topic: string) {\n    await removeSubscription(topic, () => console.log(`Removed subscription to topic: ${topic}`));\n  }\n\n  /*\n   * Renders the accordion components of the Active Conversation Dashboard\n   */\n  function renderQueueCards() {\n\n    const queueSections: AccordionData[] = queues.map((queue: Queue) => {\n      queue.conversations && console.log('QUEUE CONVERSATIONS', queue.conversations);\n      // setup conversations\n      const conversationSections: AccordionData[] = (queue.conversations || []).map((conversation: IConversation) => {\n        const section: AccordionData = {\n          sectionClass: conversation.standing === Standing.badStanding \n            ? 'accordion-section--bad-standing'\n            : 'accordion-section--good-standing',\n          contentClass: 'content--conversation',\n          heading: (\n            <React.Fragment>\n              <span className={conversation.standing === Standing.badStanding ? 'standing-header--bad' : 'standing-header--good'}>\n                {conversation.standing === Standing.badStanding \n                  ? <GenesysDevIcon icon={GenesysDevIcons.AppWarnSolid}/> \n                  : <GenesysDevIcon icon={GenesysDevIcons.AppCheckSolid}/> \n                }\n              </span>\n              <span className=\"agent-name-title\">{conversation.assignedAgent?.agentName}</span>\n              <span className=\"start-title\">\n                Active since {`${conversation.startTime?.format('h:mm a').toString()}`}\n              </span>\n           </React.Fragment>\n          ),\n          content: (\n            <Conversation conversation={conversation} />\n          ),\n          showExpanded: false,\n        }\n        return section;\n      });\n\n      const conversationHeaderClass = queue.conversationIds?.length > 0 ? 'active-header' : 'inactive-header';\n\n      const section: AccordionData = {\n        heading: (\n          <React.Fragment>\n            <span className=\"queue__header-left\">{queue.name || ''}</span>\n            <span className={conversationHeaderClass}>{`${queue.conversationIds?.length || 0} active conversations`}</span>\n          </React.Fragment>\n        ),\n        content: (\n          <div className=\"conversations-container\">\n            <Accordion sections={conversationSections} innerClass=\"inner-accordion\" />\n          </div>\n        ),\n        showExpanded: false\n      }\n      return section;\n    });\n\n    return (\n      <Accordion sections={queueSections} outerClass=\"outer-accordion\" />\n    );\n  }\n\n  return (\n    <div className=\"queue\">\n      <div className=\"queue-title\">\n          <span><span>Active Conversation Dashboard</span></span>\n          <p>This is a list of the queues in your organization.  Expand one to see the active conversations for the queue.</p>\n      </div>\n      {renderQueueCards()}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}