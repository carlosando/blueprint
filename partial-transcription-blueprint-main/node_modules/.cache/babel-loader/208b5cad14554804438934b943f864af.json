{"ast":null,"code":"const errors = require('./errors');\n/**\r\n * Regular Expression to match placeholders.\r\n * @type {RegExp}\r\n * @private\r\n */\n\n\nconst PLACEHOLDER = new RegExp(/%\\(([\\w-]+)\\)s/);\n/**\r\n * Maximum recursion depth for parseValue\r\n * @type {number}\r\n */\n\nconst MAXIMUM_INTERPOLATION_DEPTH = 50;\n/**\r\n * Recursively parses a string and replaces the placeholder ( %(key)s )\r\n * with the value the key points to.\r\n * @param {ParserConfig} parser - Parser Config Object\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n */\n\nfunction interpolate(parser, section, key) {\n  return interpolateRecurse(parser, section, key, 1);\n}\n/**\r\n * Interpolate Recurse\r\n * @param parser\r\n * @param section\r\n * @param key\r\n * @param depth\r\n * @private\r\n */\n\n\nfunction interpolateRecurse(parser, section, key, depth) {\n  let value = parser.get(section, key, true);\n\n  if (depth > MAXIMUM_INTERPOLATION_DEPTH) {\n    throw new errors.MaximumInterpolationDepthError(section, key, value, MAXIMUM_INTERPOLATION_DEPTH);\n  }\n\n  let res = PLACEHOLDER.exec(value);\n\n  while (res !== null) {\n    const placeholder = res[1];\n    const rep = interpolateRecurse(parser, section, placeholder, depth + 1); // replace %(key)s with the returned value next\n\n    value = value.substr(0, res.index) + rep + value.substr(res.index + res[0].length); // get next placeholder\n\n    res = PLACEHOLDER.exec(value);\n  }\n\n  return value;\n}\n\nmodule.exports = {\n  interpolate,\n  MAXIMUM_INTERPOLATION_DEPTH\n};","map":{"version":3,"sources":["/Users/cando001/Documents/MyGit/blueprint/partial-transcription-blueprint-main/node_modules/configparser/src/interpolation.js"],"names":["errors","require","PLACEHOLDER","RegExp","MAXIMUM_INTERPOLATION_DEPTH","interpolate","parser","section","key","interpolateRecurse","depth","value","get","MaximumInterpolationDepthError","res","exec","placeholder","rep","substr","index","length","module","exports"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,WAAW,GAAG,IAAIC,MAAJ,CAAW,gBAAX,CAApB;AAEA;AACA;AACA;AACA;;AACA,MAAMC,2BAA2B,GAAG,EAApC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,OAA7B,EAAsCC,GAAtC,EAA2C;AACvC,SAAOC,kBAAkB,CAACH,MAAD,EAASC,OAAT,EAAkBC,GAAlB,EAAuB,CAAvB,CAAzB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,kBAAT,CAA4BH,MAA5B,EAAoCC,OAApC,EAA6CC,GAA7C,EAAkDE,KAAlD,EAAyD;AACrD,MAAIC,KAAK,GAAGL,MAAM,CAACM,GAAP,CAAWL,OAAX,EAAoBC,GAApB,EAAyB,IAAzB,CAAZ;;AACA,MAAGE,KAAK,GAAGN,2BAAX,EAAuC;AACnC,UAAM,IAAIJ,MAAM,CAACa,8BAAX,CAA0CN,OAA1C,EAAmDC,GAAnD,EAAwDG,KAAxD,EAA+DP,2BAA/D,CAAN;AACH;;AACD,MAAIU,GAAG,GAAGZ,WAAW,CAACa,IAAZ,CAAiBJ,KAAjB,CAAV;;AACA,SAAMG,GAAG,KAAK,IAAd,EAAmB;AACf,UAAME,WAAW,GAAGF,GAAG,CAAC,CAAD,CAAvB;AACA,UAAMG,GAAG,GAAGR,kBAAkB,CAACH,MAAD,EAASC,OAAT,EAAkBS,WAAlB,EAA+BN,KAAK,GAAG,CAAvC,CAA9B,CAFe,CAGf;;AACAC,IAAAA,KAAK,GAAGA,KAAK,CAACO,MAAN,CAAa,CAAb,EAAgBJ,GAAG,CAACK,KAApB,IAA6BF,GAA7B,GACJN,KAAK,CAACO,MAAN,CAAaJ,GAAG,CAACK,KAAJ,GAAYL,GAAG,CAAC,CAAD,CAAH,CAAOM,MAAhC,CADJ,CAJe,CAMf;;AACAN,IAAAA,GAAG,GAAGZ,WAAW,CAACa,IAAZ,CAAiBJ,KAAjB,CAAN;AACH;;AACD,SAAOA,KAAP;AACH;;AAEDU,MAAM,CAACC,OAAP,GAAiB;AACbjB,EAAAA,WADa;AAEbD,EAAAA;AAFa,CAAjB","sourcesContent":["const errors = require('./errors');\r\n\r\n/**\r\n * Regular Expression to match placeholders.\r\n * @type {RegExp}\r\n * @private\r\n */\r\nconst PLACEHOLDER = new RegExp(/%\\(([\\w-]+)\\)s/);\r\n\r\n/**\r\n * Maximum recursion depth for parseValue\r\n * @type {number}\r\n */\r\nconst MAXIMUM_INTERPOLATION_DEPTH = 50;\r\n\r\n/**\r\n * Recursively parses a string and replaces the placeholder ( %(key)s )\r\n * with the value the key points to.\r\n * @param {ParserConfig} parser - Parser Config Object\r\n * @param {string} section - Section Name\r\n * @param {string} key - Key Name\r\n */\r\nfunction interpolate(parser, section, key) {\r\n    return interpolateRecurse(parser, section, key, 1);\r\n}\r\n\r\n/**\r\n * Interpolate Recurse\r\n * @param parser\r\n * @param section\r\n * @param key\r\n * @param depth\r\n * @private\r\n */\r\nfunction interpolateRecurse(parser, section, key, depth) {\r\n    let value = parser.get(section, key, true);\r\n    if(depth > MAXIMUM_INTERPOLATION_DEPTH){\r\n        throw new errors.MaximumInterpolationDepthError(section, key, value, MAXIMUM_INTERPOLATION_DEPTH);\r\n    }\r\n    let res = PLACEHOLDER.exec(value);\r\n    while(res !== null){\r\n        const placeholder = res[1];\r\n        const rep = interpolateRecurse(parser, section, placeholder, depth + 1);\r\n        // replace %(key)s with the returned value next\r\n        value = value.substr(0, res.index) + rep +\r\n            value.substr(res.index + res[0].length);\r\n        // get next placeholder\r\n        res = PLACEHOLDER.exec(value);\r\n    }\r\n    return value;\r\n}\r\n\r\nmodule.exports = {\r\n    interpolate,\r\n    MAXIMUM_INTERPOLATION_DEPTH\r\n};"]},"metadata":{},"sourceType":"script"}